//Code generated automatically by TMVA for Inference of Model file [PyTorchModelSequential.pt] at [Thu Jul 22 09:27:27 2021] 
#include<algorithm>
#include<vector>
namespace TMVA_SOFIE_PyTorchModelSequential{
namespace BLAS{
	extern "C" void sgemm_(const char * transa, const char * transb, const int * m, const int * n, const int * k,
	                       const float * alpha, const float * A, const int * lda, const float * B, const int * ldb,
	                       const float * beta, float * C, const int * ldc);
}//BLAS
float tensor_0weight[120] = {0.794149518, -0.29279393, 0.313918144, -0.108572431, -0.443363398, -0.348738909, -0.622504175, 0.829037428, -0.0408091992, 0.240773022, 0.052367568, 0.344153881, 0.210578501, 0.19975765, 0.865480423, 0.71599251, -0.338854253, -0.293076992, -0.42579034, 0.219462395, 0.016897615, 0.693285048, 0.918555379, -0.25138545, 0.486715347, 0.151098758, -0.200749174, -0.194673628, 0.7518664, -0.0315008014, 0.489237189, 0.0368041061, -0.0604234934, 0.855746806, 0.401435286, -0.263502568, -0.260234475, 0.224465594, 0.421963155, 0.50555712, 0.587050676, -0.468461305, -0.640900373, 0.0809974149, -0.528184474, 0.555543602, 0.880463779, 0.828012943, -0.239621758, -0.728659213, -0.0348753929, 0.200017259, 0.923660755, 0.432322562, 0.761401355, -0.538834751, 0.778423429, -0.519957304, -0.742600858, -0.280813098, -0.155247077, 0.622584581, 0.792096376, -0.0364762545, -0.260499656, -0.128390551, -0.704966187, -0.4523426, 0.0272848289, 0.213493466, 0.0616609864, -0.78773737, -0.0375506878, 0.931713402, 0.884731412, -0.72293365, 0.423022866, 0.742978573, 0.6051898, 0.581415355, 0.274649948, -0.557957411, -0.382419258, 0.661828637, -0.553941786, 0.0920590162, 0.0769542456, -0.382855356, 0.270560592, -0.499663293, 0.223693743, 0.0697988495, -0.39527002, 0.252587408, -0.517781436, -0.587131441, -0.481904119, 0.125736967, 0.048283577, -0.748652339, -0.751031935, 0.423750848, -0.175941586, -0.345719904, 0.302291811, -0.196603298, 0.506211996, 0.778486192, -0.0587669201, -0.0453001894, -0.829949856, -0.321240276, 0.577788889, 0.591493785, -0.415325671, 0.428197622, 0.451171786, -0.0290500708, 0.709549427, -0.100489117};
float tensor_0bias[120] = {-0.514827609, 0.377852023, 0.0970986113, 0.0793926865, 0.102020636, -0.990610123, 0.0745862797, -0.174509302, 0.374899656, 0.553914011, -0.747540236, 0.713300049, 0.524033546, 0.568822265, -0.474720716, 0.325140297, 0.601087511, -0.700725436, -0.659408629, -0.409963369, 0.676591396, -0.202960551, -0.909158051, -0.623494506, 0.181741714, 0.578116953, 0.683191955, 0.742755234, -0.0028623119, 0.267594397, 0.691494286, 0.347002447, -0.72454071, -0.742428184, -0.511509776, 0.390387684, 0.723461688, -0.512518525, -0.307814121, 0.0172264446, 0.190222368, -0.259036928, 0.401002228, 0.438329071, 0.022034796, 0.611411035, -0.474221498, -0.427386135, -0.866850853, -0.989632726, -0.383507133, 0.183634415, -0.651533067, -0.926905513, -0.837092876, -0.410418689, -0.893741965, -0.159216389, -0.25635469, -0.644455552, 0.146732807, -0.526811361, -0.0564663485, -0.464014411, -0.532074511, -0.649620295, 0.55707258, 0.0152339647, 0.68457514, -0.830202103, 0.51378876, -0.325610548, -0.581242204, -0.883540213, -0.935330451, -0.0180569533, 0.506103277, 0.617362678, 0.412328184, 0.583044231, 0.550618589, 0.239088714, -0.706570625, -0.939919233, 0.46359539, -0.341271758, -0.81287837, -0.264023632, 0.406400621, -0.780741692, -0.267934442, 0.086896129, 0.00930277817, -0.255141914, 0.0373347327, 0.201832503, -0.538854778, 0.737341046, -0.246022582, 0.603022873, -0.47352463, 0.218252033, 0.615670085, 0.305882037, 0.0628430545, -0.496662378, 0.595488012, -0.110998757, 0.029354509, 0.188403785, 0.240126655, -0.649940073, -0.256812841, -0.494315952, -0.711478949, -0.183329925, -0.783269167, -0.0515234582, 0.635085583, 0.380619437};
float tensor_4[14400];
float tensor_3[14400];
std::vector<float> infer(float* tensor_input1){
	char op_0_transA = 'n';
	char op_0_transB = 't';
	int op_0_m = 120;
	int op_0_n = 120;
	int op_0_k = 1;
	float op_0_alpha = 1;
	float op_0_beta = 1;
	int op_0_lda = 1;
	int op_0_ldb = 1;
	std::copy(tensor_0bias, tensor_0bias + 120, tensor_3);
	BLAS::sgemm_(&op_0_transB, &op_0_transA, &op_0_n, &op_0_m, &op_0_k, &op_0_alpha, tensor_0weight, &op_0_ldb, tensor_input1, &op_0_lda, &op_0_beta, tensor_3, &op_0_n);
	for (int id = 0; id < 14400 ; id++){
		tensor_4[id] = ((tensor_3[id] > 0 )? tensor_3[id] : 0);
	}
	std::vector<float> ret (tensor_4, tensor_4 + sizeof(tensor_4) / sizeof(tensor_4[0]));
	return ret;
}
} //TMVA_SOFIE_PyTorchModelSequential
