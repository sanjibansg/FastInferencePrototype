//Code generated automatically by TMVA for Inference of Model file [PyTorchModelSequential.pt] at [Mon Jul 26 18:19:23 2021] 
#include<algorithm>
#include<vector>
namespace TMVA_SOFIE_PyTorchModelSequential{
namespace BLAS{
	extern "C" void sgemm_(const char * transa, const char * transb, const int * m, const int * n, const int * k,
	                       const float * alpha, const float * A, const int * lda, const float * B, const int * ldb,
	                       const float * beta, float * C, const int * ldc);
}//BLAS
float tensor_0weight[120] = {-0.152240485, -0.132029295, 0.339252025, 0.0370297432, 0.234811187, 0.0846173018, 0.872076392, -0.599342942, -0.00530815125, -0.505340576, -0.536257565, 0.553227127, 0.128034666, -0.57493645, -0.0661481991, -0.30552125, -0.27488637, -0.442312032, -0.172247678, -0.171690255, -0.248673558, 0.73276037, 0.537614584, 0.485078514, -0.0400623642, -0.517049134, -0.533793211, -0.187144756, -0.27179417, 0.246879578, -0.579834282, 0.553756356, 0.574917495, 0.300205499, 0.381613016, 0.517327905, -0.219778061, 0.25465703, 0.642411232, -0.0866396427, -0.539625347, 0.915490448, 0.610517919, -0.338394821, -0.389429748, 0.645381987, -0.281023145, 0.703257561, -0.0798727274, 0.306671619, -0.695894897, -0.825151086, 0.503169179, -0.293206304, -0.597933292, 0.611142695, 0.734155655, -0.709797561, 0.195421457, 0.821853161, -0.703675508, -0.572639108, -0.273546994, -0.0853372812, 0.157393038, -0.477534145, 0.253719002, 0.713917971, 0.0404695272, 0.440648288, -0.350077182, -0.471219659, 0.876136661, -0.503728151, 0.496330112, -0.419422597, -0.0561317168, 0.531975687, 0.0295453072, 0.444325894, 0.771233082, -0.626610458, -0.61349684, 0.526675999, -0.298161536, -0.526281536, -0.263522118, -0.306266725, -0.818688869, 0.67385, 0.591412187, -0.36388272, 0.0302493572, -0.211096182, -0.427239031, 0.148200288, -0.455286026, 0.146175727, 0.125521258, -0.622406065, 0.363431841, -0.54901439, 0.624209046, -0.733142376, 0.406487644, 0.694423914, 0.0292160511, 0.110454939, 0.185824752, -0.383215487, -0.572317839, 0.88137269, -0.638968527, 0.0456612334, -0.617945373, 0.743625104, -0.0680777207, 0.575315475, -0.38330242, -0.338599712};
float tensor_0bias[120] = {-0.123710632, -0.621587396, -0.0726617798, -0.431109905, -0.548410892, 0.0633216202, -0.954460204, 0.490127057, -0.366846681, -0.463219434, -0.470677346, 0.171322629, 0.310211867, 0.364942491, 0.467593133, -0.398629069, 0.328724563, 0.729939878, 0.57122159, -0.14991726, -0.529278278, 0.22792539, -0.584588468, -0.919878185, 0.4533889, -0.686462939, 0.0882127509, -0.934179902, 0.290726155, -0.855553746, -0.927060604, -0.314189494, -0.856917799, -0.032534644, -0.597157001, -0.243418559, -0.897915602, -0.0491208807, -0.899757624, -0.962168097, -0.387023091, -0.769109309, 0.12533994, -0.816546798, -0.62844342, -0.165952459, -0.999395251, -0.931136131, -0.951467514, -0.816911459, -0.418010265, -0.499963582, -0.847769737, 0.199441627, -0.319086701, -0.468817294, -0.116343848, -0.961705327, -0.87353909, -0.350952327, -0.745907187, 0.552627325, -0.0461826921, -0.849251866, 0.401941806, 0.147042692, 0.270939082, -0.119532488, -0.745719671, 0.314937145, -0.787264526, 0.295671761, -0.111996174, -0.950633049, -0.873144209, 0.0933051929, 0.345641196, 0.657602131, -0.221394539, -0.214924678, -0.945144475, 0.246871233, 0.0359299928, -0.369029105, -0.790218472, 0.1113552, -0.568451703, 0.3657673, -0.675646245, -0.0691977739, 0.637923241, -0.254906774, -0.564000607, -0.105960548, 0.223683029, 0.223500341, -0.0333369635, 0.488509536, -0.130210757, -0.287199557, 0.319371551, 0.450984687, -0.387744576, -0.562528908, 0.537441194, 0.446737438, -0.846797824, 0.497184187, 0.447029203, 0.188793108, 0.0854884461, -0.175018787, 0.485370517, 0.00259962515, 0.258006752, -0.495795369, -0.11162851, -0.604441941, 0.333826989, -0.70623666};
float tensor_4[14400];
float tensor_3[14400];
std::vector<float> infer(float* tensor_input1){
	char op_0_transA = 'n';
	char op_0_transB = 't';
	int op_0_m = 120;
	int op_0_n = 120;
	int op_0_k = 1;
	float op_0_alpha = 1;
	float op_0_beta = 1;
	int op_0_lda = 1;
	int op_0_ldb = 1;
	std::copy(tensor_0bias, tensor_0bias + 120, tensor_3);
	BLAS::sgemm_(&op_0_transB, &op_0_transA, &op_0_n, &op_0_m, &op_0_k, &op_0_alpha, tensor_0weight, &op_0_ldb, tensor_input1, &op_0_lda, &op_0_beta, tensor_3, &op_0_n);
	for (int id = 0; id < 14400 ; id++){
		tensor_4[id] = ((tensor_3[id] > 0 )? tensor_3[id] : 0);
	}
	std::vector<float> ret (tensor_4, tensor_4 + sizeof(tensor_4) / sizeof(tensor_4[0]));
	return ret;
}
} //TMVA_SOFIE_PyTorchModelSequential
